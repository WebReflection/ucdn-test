export default(e,l,t,i,f)=>{const n=t.length;let r=l.length,s=n,o=0,g=0,h=null;for(;o<r||g<s;)if(r===o){const l=s<n?g?i(t[g-1],-0).nextSibling:i(t[s-g],0):f;for(;g<s;)e.insertBefore(i(t[g++],1),l)}else if(s===g)for(;o<r;)h&&h.has(l[o])||e.removeChild(i(l[o],-1)),o++;else if(l[o]===t[g])o++,g++;else if(l[r-1]===t[s-1])r--,s--;else if(l[o]===t[s-1]&&t[g]===l[r-1]){const f=i(l[--r],-1).nextSibling;e.insertBefore(i(t[g++],1),i(l[o++],-1).nextSibling),e.insertBefore(i(t[--s],1),f),l[r]=t[s]}else{if(!h){h=new Map;let e=g;for(;e<s;)h.set(t[e],e++)}if(h.has(l[o])){const f=h.get(l[o]);if(g<f&&f<s){let n=o,c=1;for(;++n<r&&n<s&&h.get(l[n])===f+c;)c++;if(c>f-g){const n=i(l[o],0);for(;g<f;)e.insertBefore(i(t[g++],1),n)}else e.replaceChild(i(t[g++],1),i(l[o++],-1))}else o++}else e.removeChild(i(l[o++],-1))}return t};