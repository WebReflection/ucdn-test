import umap from"../../umap/esm/index.js";import instrument from"../../uparser/esm/index.js";import{isArray}from"../../uarray/esm/index.js";import{persistent}from"../../uwire/esm/index.js";import{handlers}from"./handlers.js";import{createFragment,createPath,createWalker,importNode}from"./node.js";const prefix="isµ",cache=umap(new WeakMap);export const createCache=()=>({stack:[],entry:null,wire:null});const createEntry=(t,e)=>{const{content:r,updates:n}=mapUpdates(t,e);return{type:t,template:e,content:r,updates:n,wire:null}},mapTemplate=(t,e)=>{const r=instrument(e,"isµ","svg"===t),n=createFragment(r,t),a=createWalker(n),s=[],o=e.length-1;let l=0,p="isµ"+l;for(;l<o;){const t=a.nextNode();if(!t)throw"bad template: "+r;if(8===t.nodeType)t.textContent===p&&(s.push({type:"node",path:createPath(t)}),p="isµ"+ ++l);else{for(;t.hasAttribute(p);)s.push({type:"attr",path:createPath(t),name:t.getAttribute(p)}),t.removeAttribute(p),p="isµ"+ ++l;/^(?:style|textarea)$/i.test(t.tagName)&&t.textContent.trim()===`\x3c!--${p}--\x3e`&&(s.push({type:"text",path:createPath(t)}),p="isµ"+ ++l)}}return{content:n,nodes:s}},mapUpdates=(t,e)=>{const{content:r,nodes:n}=cache.get(e)||cache.set(e,mapTemplate(t,e)),a=importNode.call(document,r,!0);return{content:a,updates:n.map(handlers,a)}};export const unroll=(t,{type:e,template:r,values:n})=>{const{length:a}=n;unrollValues(t,n,a);let{entry:s}=t;s&&s.template===r&&s.type===e||(t.entry=s=createEntry(e,r));const{content:o,updates:l,wire:p}=s;for(let t=0;t<a;t++)l[t](n[t]);return p||(s.wire=persistent(o))};const unrollValues=({stack:t},e,r)=>{for(let n=0;n<r;n++){const r=e[n];r instanceof Hole?e[n]=unroll(t[n]||(t[n]={stack:[],entry:null,wire:null}),r):isArray(r)?unrollValues(t[n]||(t[n]={stack:[],entry:null,wire:null}),r,r.length):t[n]=null}r<t.length&&t.splice(r)};export function Hole(t,e,r){this.type=t,this.template=e,this.values=r}