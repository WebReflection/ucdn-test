import{render as e,html as t,svg as n}from"../../uhtml/esm/index.js";import s from"../../umap/esm/index.js";const c=customElements,{define:a}=c,{create:o,defineProperties:l,getOwnPropertyDescriptor:i,keys:r}=Object,p=s(new Map([["element",{c:HTMLElement,e:"element"}]])),u=e=>p.get(e)||p.set(e,{c:document.createElement(e).constructor,e:e});export{e as render,t as html,n as svg};export const define=(e,t)=>{const{attachShadow:n,attributeChanged:s,connected:h,disconnected:m,handleEvent:b,init:f,observedAttributes:g,props:v}=t,y=new WeakMap,w={},k={},x=[],C=o(null);for(let e=r(t),n=0,{length:s}=e;n<s;n++){const s=e[n];if(/^on/.test(s)&&!/Options$/.test(s)){const e=t[s+"Options"]||!1,n=s.toLowerCase();let c=n.slice(2);x.push({type:c,options:e}),C[c]=s,n!==s&&(c=n.slice(2,3)+s.slice(3),C[c]=s,x.push({type:c,options:e}))}switch(s){case"attachShadow":case"observedAttributes":break;default:k[s]=i(t,s)}}const{length:E}=x;E&&!b&&(k.handleEvent={value(e){this[C[e.type]](e)}}),v||(k.props={get(){const e={};for(let{attributes:t}=this,{length:n}=t,s=0;s<n;s++){const{name:n,value:c}=t[s];e[n]=c}return e}}),g&&(w.observedAttributes={value:g}),k.attributeChangedCallback={value(){S(this),s&&s.apply(this,arguments)}},k.connectedCallback={value(){S(this),h&&h.apply(this,arguments)}},m&&(k.disconnectedCallback={value:m});const{c:O,e:A}=u(t.extends||"element");class L extends O{}l(L,w),l(L.prototype,k);const M=[e,L];function S(e){if(!y.has(e)){y.set(e,0),l(e,{html:{value:d.bind(n?e.attachShadow(n):e)}});for(let t=0;t<E;t++){const{type:n,options:s}=x[t];e.addEventListener(n,e,s)}f&&f.call(e)}}"element"!==A&&M.push({extends:A}),a.apply(c,M),p.set(e,{c:L,e:A})};function d(){return e(this,t.apply(null,arguments))}c.get("uce-lib")||c.define("uce-lib",class extends u("element").c{static get define(){return define}static get render(){return e}static get html(){return t}static get svg(){return n}});